:PROPERTIES:
:ID:       565cc737-ce08-43bb-be8e-58416208951e
:END:
#+title: Obsidian - Plugin Manager
#+auto_tangle: t

* Table of Contents :toc:
- [[#description][Description]]
  - [[#manual-installation][(Manual) Installation]]
- [[#the-program][The Program]]
  - [[#effects][Effects]]
  - [[#preamble][Preamble]]
  - [[#logic][Logic]]
  - [[#x-toggle-plugin][[X] Toggle Plugin]]
  - [[#x-get-list-of-installed-plugins][[X] Get List of Installed Plugins]]
  - [[#specific-library][Specific Library]]
  - [[#obsidian-overhead][Obsidian Overhead]]
- [[#environment--compilation][Environment & Compilation]]
  - [[#compile-with-org-babel-tangle][Compile With Org-Babel-Tangle]]
  - [[#eslint][ESLint]]
  - [[#dependencies][Dependencies]]
  - [[#manifest][Manifest]]
  - [[#brat-manifest][BRAT Manifest]]
- [[#scripts][Scripts]]
  - [[#bump-version][Bump Version]]
- [[#credits][Credits]]
- [[#license][LICENSE]]

* Description
This is a plugin which manages plugins for [Obsidian.md](https://obsidian.md/).

*Features*:
- Lazy Loading. Create a startup delay for a given plugin.
- Plugin toggling via command and/or hotkey.

** (Manual) Installation
Until the plugin has been published to the community tab, please use the below method to install:

1. Download the latest `main.js` & `manifest.json` from the latest [[https://github.com/ohm-en/obsidian-plugin-manager/releases][release]].
2. Create a folder--with any name--in `.obsidian/plugins` at your vaults location.
3. Move the downloaded files into the created folder.
4. After reloading the Obsidian plugin list, you will see the plugin disabled. Enable it.

* The Program
This plugin is written as a literate program. If you'd like to read the source-code, you'll find its entirety below with relevant descriptions.

** Effects
- Obsidian API:
  - Register Settings panel
  - Register commands
  - Read/save settings data
  - Alter plugin state

** Preamble
*** Libraries

The program only depends on the Obsidian API. Though unclear, this includes all functions, methods, etc. under `obsidian`, `plugin`, and `app`.

#+NAME: dependencies
#+begin_src js
var obsidian = require('obsidian');
#+end_src
*** Arguments

Our program (plugin) is called by the Obsidian application based off our exported module (see [[target]]).

At runtime, the program receives two variables from Obsidian: `app` and `manifest`. These values are used excursively to interact the Obsidian API. Please see the [[https://github.com/obsidianmd/obsidian-api][documentation]] for more information.

*** Global Store
:PROPERTIES:
:header-args: :noweb-ref store 
:END:

A single global object will be used as our "store" throughout the program. It known as the `pluginArr` and is used to defer ideally all mutable data. Additionally, we use a listener on the object to reflect its state onto the environment.

**** Saved Settings
Our store will furthermore be cached on the system using the Obsidian API (in a file titled `data.json`). The program has no support for lazy loading without this file. However, for other functions, we create some initial data if the cache has no or little data.

#+begin_src js
const DEFAULT_SETTINGS = {
    pluginArr: function() {
        let array = {}
        Object.keys(app.plugins.manifests).forEach(
            function(pluginId) {
                array[pluginId] = { id: pluginId, delay: 0, enabled: pluginStatus(pluginId) }
            })
        return array
        }(),
}
const pluginSettings = Object.assign({}, DEFAULT_SETTINGS, await plugin.loadData());
#+end_src

**** The Global Listener
In hopes of containing complexity in the program, this listener attempts to maintain the proper environment state by listening to changes to the global object, `pluginArr`. It's primary goal is to keep each plugin in the correct state of enablement.

Plugin States:
1. Enabled & Saved    | Enabled on boot
2. Enabled & Unsaved  | Enabled until next boot 
3. Disabled & Saved   | Disabled
4. Disabled & Unsaved | Disabled until next boot

#+begin_src js
const pluginListen = {
	async set(obj, prop, value) {
	    const nbj = Object.assign({}, obj); nbj[prop] = value;
	    const { id } = obj;
	  	if (nbj.enabled) {
			// If lazy loading disabled
			if (nbj.delay == 0) { app.plugins.enablePluginAndSave(id); }
			// If lazy loading newly enabled
			else if (obj.delay == 0) { app.plugins.disablePluginAndSave(id); app.plugins.enablePlugin(id) }
			// If lazy loading already enabled
			else { app.plugins.enablePlugin(id) }
		}
		else {
			app.plugins.disablePluginAndSave(id)
		 }
	    Reflect.set(...arguments)
		await plugin.saveData(pluginSettings);
	    return true
	}
}

const pluginArr = {};
Object.entries(pluginSettings.pluginArr)
    .forEach(
        function([id, pluginObj]) {
            pluginArr[id] = new Proxy(pluginObj, pluginListen);
        })
#+end_src

** Functions 
:PROPERTIES:
:header-args: :noweb-ref specific-library
:END:
*** Check If Plugin Is Enabled
Checks the "true" status of a plugin's status using the Obsidian API. This does not check with the global object, but they should always match regardless.

#+begin_src js
const pluginStatus = function(pluginId) {
	return app.plugins.plugins.hasOwnProperty(pluginId);
}
#+end_src

** Logic
:PROPERTIES:
:header-args: :noweb-ref business-logic
:END:
*** Lazy Load Plugins
The original purpose of this plugin was to implement an easier variation of TftHacker's lazy-loading.

Using a saved listed of plugins and their relevant on load delay, this is trivially achieved with Obsidian's `app.plugins.enablePlugin` function.

This fn puts the plugin in a currently enabled state but disabled on boot. Therefore to achieve lazy loading, we only need to set a function on start which enables relevant plugins based on their delay.

Note: `app.plugins.enablePlugin` only works if `app.plugin.enablePluginAndSave` has not been first used. If that's the case, you must first disable it with `app.plguin.disablePluginAndSave`.

#+begin_src js
Object.entries(pluginArr).forEach(
    function([id, data]) {
        if (data.enabled & data.delay > 0) {
            setTimeout(
                function() {
                    app.plugins.enablePlugin([id])
                }, data.delay)
        }
    }
);
#+end_src
*** Quick Toggle For Plugins
Takes a list of installed plugins and creates a corresponding array of Obsidian commands which are responsible for toggling the relevant plugin on/off. If desired, the user can add a keybinding using the Obsidian GUI.

For this to work, we first need a function which toggles the plugin's state on/off while maintaining the proper state (for lazy loading); however, this is already handled by the global listener, so we only need to change the value of `pluginArr[id].enabled` to its inverse.

Furthermore, we need an object which abides by Obsidian's command API. This simply requires a `id`, `name`, and `callback` (fn) as attributes which the below command handles nicely.

#+begin_src js
const createToggleCommand = function({id, name}) {
    const obj = {id: `toggle-${id}`,
                name: `toggle ${name}`,
                callback: function() {
                            pluginArr[id].enabled = !pluginArr[id].enabled
                        }
    }
    return obj
}
#+end_src

Using the above function to generate the required JS object, we only need to map over a list of plugins (provided by manifests in the case) to add each command one by one.

#+begin_src js :noweb yes
Object.values(app.plugins.manifests)
	  .map(createToggleCommand)
	  // `addCommand` needs to be wrapped in a function. I suspect it's accessing local variables?
	  .map(function(obj) { plugin.addCommand(obj) });
#+end_src

*** Register Settings Panel

The settings panel is a list of every installed plugin with a few options. The following loops between each plugin and adds it to the settings panel.

#+begin_src js
const MySettingTab = new obsidian.PluginSettingTab(app, plugin)
MySettingTab.display = async function() {
	const { containerEl: El } = MySettingTab;
	El.empty();
	Object.entries(app.plugins.manifests).forEach(
		function([id, pluginData], index, arr) {
			if (! pluginArr[id]) {
				pluginArr[id] = { id: id, delay: 0, enabled: pluginStatus(id) }
			}
			const data = pluginArr[id];
			const st = new obsidian.Setting(El)
			const manifest = app.plugins.manifests[id]
			st.setName(manifest.name)
			st.setDesc(manifest.description)
			st.addToggle(
				function(tg) {
					tg.setValue(pluginStatus(id))
					tg.onChange(
						function(value) {
                            pluginArr[id].enabled = value;
						})
				})
			st.addText(
				function(tx) {
					tx.inputEl.type = "number"
				    const delayInSeconds = (data.delay / 1000).toString()
					tx.setValue(delayInSeconds)
					tx.onChange(function(delay) {
					    pluginArr[id].delay = Number(delay * 1000)
					})
				})
		}
	)
}
#+end_src

Now that we've created the settings panel we need to register it with the `addSettingTab` API function.

#+begin_src js
plugin.addSettingTab(MySettingTab);
#+end_src

** Obsidian Overhead
To utilize the Obsidian API, we must extend the `Plugin` object. This object contains most the methods for interacting with the API.

To do so, it's normally done with a class using the `extent` keyword to the Plugin class (`class MyPlugin extends Plugin`), but I've chosen to use a simple function which returns the a plugin object as classes are annoying to work with.

Furthermore, code put within the `plugin.onload` function will be our entry point.

#+NAME: entry-point
#+begin_src javascript :noweb yes
function constructor(app, manifest) {
	const plugin = new obsidian.Plugin(app, manifest)
    plugin.onload = async function() {
        <<specific-library>>
        <<store>>
        <<business-logic>>
    }
	return plugin; }
#+end_src

* Environment & Compilation
** Compile With Org-Babel-Tangle

#+begin_src js :noweb yes :tangle ./main.js
'use strict';

<<dependencies>>

<<entry-point>>
module.exports = constructor;
#+end_src
** ESLint
** Dependencies

#+begin_src json :tangle ./package.json
{
	"name": "obsidian-sample-plugin",
	"version": "0.1.1",
	"description": "",
	"main": "main.js",
	"scripts": {
		"dev": "npx rollup --config rollup.config.js -w",
		"build": "npx rollup --config rollup.config.js --environment BUILD:production",
		"version": "node version-bump.mjs && git add manifest.json versions.json"
	},
	"keywords": [],
	"author": "ohm-en",
	"license": "MIT",
	"devDependencies": {
		"@types/node": "^16.11.6",
		"builtin-modules": "^3.2.0",
		"eslint": "^8.25.0",
		"eslint-config-google": "^0.14.0",
		"obsidian": "^0.12.17",
	}
}
#+end_src

** Manifest
#+begin_src json :tangle manifest.json
{
	"id": "obsidian-plugin-manager",
	"name": "Obsidian Plugin Manager",
	"version": "0.1.1",
	"minAppVersion": "0.13.14",
	"description": "Better plugin management.",
	"author": "ohm-en",
	"authorUrl": "https://github.com/ohm-en",
	"isDesktopOnly": false
}
#+end_src

*** BRAT/Beta
A "beta" manifest file for [[https://github.com/TfTHacker/obsidian42-brat][BRAT]] proper support. Expect for the version number It's the same as the normal manifest.

#+begin_src json :tangle ./manifest-beta.json
{
	"id": "obsidian-plugin-manager",
	"name": "Obsidian Plugin Manager",
	"version": "0.1",
	"minAppVersion": "0.13.14",
	"description": "Better plugin management.",
	"author": "ohm-en",
	"authorUrl": "https://github.com/ohm-en",
	"isDesktopOnly": false
}
#+end_src

* Scripts
** Bump Version
#+begin_src js
import { readFileSync, writeFileSync } from "fs";

const targetVersion = process.env.npm_package_version;

// read minAppVersion from manifest.json and bump version to target version
let manifest = JSON.parse(readFileSync("manifest.json", "utf8"));
const { minAppVersion } = manifest;
manifest.version = targetVersion;
writeFileSync("manifest.json", JSON.stringify(manifest, null, "\t"));

// update versions.json with target version and minAppVersion from manifest.json
let versions = JSON.parse(readFileSync("versions.json", "utf8"));
versions[targetVersion] = minAppVersion;
writeFileSync("versions.json", JSON.stringify(versions, null, "\t"));
#+end_src

* Credits
A huge thanks to [[https://twitter.com/tfthacker/][@TfTHacker]] for creating the original implementation of lazy loading as found [[https://tfthacker.medium.com/improve-obsidian-startup-time-on-older-devices-with-the-faststart-script-70a6c590309f][here]].

* LICENSE
#+begin_src text :tangle ./LICENSE
MIT License

Copyright (c) 2022 ohm-en

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
#+end_src
